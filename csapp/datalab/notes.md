## 知识点

### 一、补码

即“对负数的绝对值按位取反再+1”

> 更符合补码的原理,对补码更加自然的解释是：对于负数−𝑥−x,"若数据类型为n个二进制位,则补码为2𝑛−𝑥2n−x".也就是说,这个补码其实就是−𝑥−x,只不过是对2𝑛2n取模之后的−𝑥−x.这样就能理解,为什么减去一个数等于加上这个数的补码,因为补码无非是这个数在模意义下的相反数.

int类型中最小的数为

0x80000000 == 10000000 00000000 00000000 00000000B

int类型中最大的数为

0x7fffffff == 01111111 1111111 1111111 11111111

其中最左边一位为符号位，符号位为0，表示正数，为1表示负数。

### 二、移码

将数值加上一个特定的偏置常数bias表示

IEEE浮点标准中 bias=2^(n-1) -1（二的n减一次方减一，n为编码位数）

如当bias==8时,

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyxv6losgj308i070wf7.jpg)

### 三、浮点数

C语言的float通常是指IEEE二进制浮点数算术标准中的单精确度，而double是指双精确度

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyxuutw2qj31360gq0sq.jpg)

其中s为符号位，exp为阶码，frac为尾数

#### 1.规范化的值

当exp的位模式既不全为0，也不全为1时，所表示的数是规范化形式

阶码字段被解释为移码表示的有符号整数（bias单精度为2^7-1=127，双精度为2^11-1=1023)，阶的值E=e-bias（e即exp表示的有符号整数）

小数字段frac被解释为描述小树值f，尾数定义为M=1+f

即表示的值为

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggyyd25yt0j306m03k0pg.jpg)

#### 2.非规范化的值

当exp的位模式全为0时，所表示的数是非规范化形式

阶的值E=1-bias

尾数M=F，不包含隐含的开头的1

#### 3.特殊值

当exp的位模式全为1时

<1>小数域frac全为0，表示无穷

<2>小数域frac不全为0，表示NaN（Not a Number）

> ### 二进制1 10000010 00001000000000000000000是一个单精度浮点数，对应的十进制数是多少？
>
> 最高位为1，表示负数；
>
> 指数位为100000102 = 13010，130 – 127 = 3；
>
> 尾数为00001000000000000000000，换成十进制为1 + 1/32。注意这里的1不要忘了加。
>
> 所以表示的数为-(1 + 1/32) * 2^3 = -8.25
>
> ### 求非规约数0 00000000 00000000000000000000001所表示的十进制
>
> 因为是非规约数，所以指数位是1 -127 = -126，而不是0 - 127 = -127；
>
> 非规约数的尾数部分没有隐含的1，所以尾数部分为2^(-23)；
>
> 所以对应的十进制为2^(-23) * 2^(-126) = 2^(-149),这是非规约数所能表示的最小的正数。
>
> 同理非规约数所能表示的最大负数为1 00000000 00000000000000000000001= -2^(-149)

### 四、整数除运算

对于带符号整数来说，n位整除n位整数，除了-2^(n-1)/(-1)=2^n-1会发生溢出外，其余情况都不会发生溢出

这是因为商的绝对值不可能比被除数的绝对值大。

在不能整除的时候，通常朝0方向舍入，即商的绝对值取比自身小的最接近整数

朝0舍入：

- 无符号数、带符号正整数：向左移出低位直接丢弃

    14/4=3		->		0000 1110B >> 2 = 000 0011B

- 带符号负整数：加偏移量2^k-1，然后再右移k位，低位丢弃（k为右移的位数）

    -14/4=-3		->		(k=2),则(-14+2^2-1)/4=-3		->		(1111 0010B + 0000 0011B) >> 2 = 1111 1101B(-3)

## datalab

在bits.c里，后面的浮点数操作就不大会了
